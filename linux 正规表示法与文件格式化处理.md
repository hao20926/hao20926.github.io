# linux 正规表示法与文件格式化处理

## `grep` 进阶用法
````bash
grep [-A] [-B] [--color=auto] '搜寻字符串' filename

选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色
````

## 基础正规表示法字符汇整

|    RE 字符   |                          意义                                  |
| :-----------: | :-------------------------------------------------------: |
|   ^word   |    待搜寻的字符串(word)在行首！                 |  
|   word$   |     待搜寻的字符串(word)在行尾！                | 
|      .        |       代表『一定有一个任意字符』的字符！      | 
|      \       |       跳脱字符，将特殊符号的特殊意义去除！   | 
|      *      |      重复零个到无穷多个的前一个 RE 字符         | 
|    [list]   |    字符集合的 RE 字符，里面列出想要撷取的字符！| 
| [n1-n2]  |   字符集合的 RE 字符，里面列出想要撷取的字符范围！ | 
|  [^list]   |     字符集合的 RE 字符，里面列出不要的字符串或范围！| 
|  \{n,m\}  |    意义：连续 n 到 m 个的『前一个 RE 字符』,意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符,意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！| 


## `sed`  分析 standard input  将数据进行取代、删除、新增、摘取特定行
````bash
 sed [-nefr] [动作]

选项与参数：
-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。
 但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。
-e ：直接在指令列模式上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；
-r ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
-i ：直接修改读取的文件内容，而不是由屏幕输出。
````
````bash
动作说明： [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
 是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』
function 有底下这些咚咚：
a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！
 例如 1,20's/old/new/g' 就是啦！
````
### 部分数据的搜寻并取代的功能

````bash
sed 's/要被取代的字符串/新的字符串/g'
ex.  取得 IP 数据(只显示ip )
/sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' \
> | sed 's/ *netmask.*$//g' 
````


### 直接修改文件内容(危险动作)

````bash
ex.
利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !
sed -i  's/\.$/\!/g'  regular_express.txt
ex.
利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』
sed -i  '$a # This is a test'  regular_express.txt
````

## `egrep`   延伸型的正规表示法

|    RE 字符   |                          意义                                  |
| :-----------: | :-------------------------------------------------------: |
|    +   |      重复『一个或一个以上』的前一个 RE 字符 ex.( egrep -n 'go+d' )   | 
|    ?    |     『零个或一个』的前一个 RE 字符     | 
|   |     |       用或( or )的方式找出数个字符串      | 
|     ()  |           找出『群组』字符串,并以 | 来分隔开来   | 
|   ()+  |          多个重复群组的判别   egrep 'A(xyz)+C'  | 

## `printf`  格式化打印
````bash
printf '打印格式' 实际内容

选项与参数：
关于格式方面的几个特殊样式：
 \a 警告声音输出
 \b 退格键(backspace)
 \f 清除屏幕 (form feed)
 \n 输出新的一行
 \r 亦即 Enter 按键
 \t 水平的 [tab] 按键
 \v 垂直的 [tab] 按键
 \xNN NN 为两位数的数字，可以转换数字成为字符。
关于 C 程序语言内，常见的变数格式
 %ns 那个 n 是数字， s 代表 string ，亦即多少个字符；
 %ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；
 %N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，
 假设我共要十个位数，但小数点有两位，即为 %10.2f 啰！
````

## `awk` 数据处理工具
````bash
awk '条件类型 1{动作 1} 条件类型 2{动作 2} ...' filename

ex.  列出登录用户前五行，并过滤空白行，并列出每一行的行数NR,以及改行多少字段NF.
last -n 5 | grep -v '^$' |  awk '{print $1 "\t lines: " NR "\t columns: " NF  }'

root     lines: 1        columns: 10
root     lines: 2        columns: 10
root     lines: 3        columns: 10
root     lines: 4        columns: 10
root     lines: 5        columns: 10
wtmp     lines: 6        columns: 7
````

|    变量名称   |            代表意义           |
| :-----------: | :-------------------------------------------------------: |
|    NF    |     每一行 ($0) 拥有的字段总数            |  
|    NR   |   目前 awk 所处理的是『第几行』数据    | 
|    FS    |   目前的分隔字符，默认是空格键     | 

## awk 的逻辑运算字符
````bash

>          大于
<         小于
>=      大于或等于
<=      小于或等于
==      等于
!=       不等于
ex.  仅列出账号与第三栏且第三栏小于10的数据
cat /etc/passwd | awk ' BEGIN {FS=":"} $3 <10 {print $1 "\t" $3}'

root    0
bin     1
daemon  2
adm     3
lp      4
sync    5

````
